# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: temporal/api/workflowservice/v1/request_response.proto, temporal/api/workflowservice/v1/service.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import Dict, List, Optional

import betterproto
import grpclib

from .temporal.api.command import v1
from .temporal.api.common import v1
from .temporal.api.enums import v1
from .temporal.api.failure import v1
from .temporal.api.filter import v1
from .temporal.api.history import v1
from .temporal.api.namespace import v1
from .temporal.api.query import v1
from .temporal.api.replication import v1
from .temporal.api.taskqueue import v1
from .temporal.api.version import v1
from .temporal.api.workflow import v1


@dataclass
class RegisterNamespaceRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    owner_email: str = betterproto.string_field(3)
    workflow_execution_retention_period_days: int = betterproto.int32_field(4)
    emit_metric: bool = betterproto.bool_field(5)
    clusters: List[v1.ClusterReplicationConfig] = betterproto.message_field(6)
    active_cluster_name: str = betterproto.string_field(7)
    # A key-value map for any customized purpose.
    data: Dict[str, str] = betterproto.map_field(
        8, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    security_token: str = betterproto.string_field(9)
    is_global_namespace: bool = betterproto.bool_field(10)
    # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server
    # configuration is used.
    history_archival_state: v1.ArchivalState = betterproto.enum_field(11)
    history_archival_uri: str = betterproto.string_field(12)
    # If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server
    # configuration is used.
    visibility_archival_state: v1.ArchivalState = betterproto.enum_field(13)
    visibility_archival_uri: str = betterproto.string_field(14)


@dataclass
class RegisterNamespaceResponse(betterproto.Message):
    pass


@dataclass
class ListNamespacesRequest(betterproto.Message):
    page_size: int = betterproto.int32_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class ListNamespacesResponse(betterproto.Message):
    namespaces: List["DescribeNamespaceResponse"] = betterproto.message_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class DescribeNamespaceRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    id: str = betterproto.string_field(2)


@dataclass
class DescribeNamespaceResponse(betterproto.Message):
    namespace_info: v1.NamespaceInfo = betterproto.message_field(1)
    config: v1.NamespaceConfig = betterproto.message_field(2)
    replication_config: v1.NamespaceReplicationConfig = betterproto.message_field(3)
    failover_version: int = betterproto.int64_field(4)
    is_global_namespace: bool = betterproto.bool_field(5)


@dataclass
class UpdateNamespaceRequest(betterproto.Message):
    """
    (-- api-linter: core::0134::request-mask-required=disabled     aip.dev/not-
    precedent: UpdateNamespace RPC doesn't follow Google API format. --) (--
    api-linter: core::0134::request-resource-required=disabled     aip.dev/not-
    precedent: UpdateNamespace RPC doesn't follow Google API format. --)
    """

    name: str = betterproto.string_field(1)
    update_info: v1.UpdateNamespaceInfo = betterproto.message_field(2)
    config: v1.NamespaceConfig = betterproto.message_field(3)
    replication_config: v1.NamespaceReplicationConfig = betterproto.message_field(4)
    security_token: str = betterproto.string_field(5)
    delete_bad_binary: str = betterproto.string_field(6)


@dataclass
class UpdateNamespaceResponse(betterproto.Message):
    namespace_info: v1.NamespaceInfo = betterproto.message_field(1)
    config: v1.NamespaceConfig = betterproto.message_field(2)
    replication_config: v1.NamespaceReplicationConfig = betterproto.message_field(3)
    failover_version: int = betterproto.int64_field(4)
    is_global_namespace: bool = betterproto.bool_field(5)


@dataclass
class DeprecateNamespaceRequest(betterproto.Message):
    name: str = betterproto.string_field(1)
    security_token: str = betterproto.string_field(2)


@dataclass
class DeprecateNamespaceResponse(betterproto.Message):
    pass


@dataclass
class StartWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_id: str = betterproto.string_field(2)
    workflow_type: v1.WorkflowType = betterproto.message_field(3)
    task_queue: v1.TaskQueue = betterproto.message_field(4)
    input: v1.Payloads = betterproto.message_field(5)
    # Total workflow execution timeout including retries and continue as new.
    workflow_execution_timeout_seconds: int = betterproto.int32_field(6)
    # Timeout of a single workflow run.
    workflow_run_timeout_seconds: int = betterproto.int32_field(7)
    # Timeout of a single workflow task.
    workflow_task_timeout_seconds: int = betterproto.int32_field(8)
    identity: str = betterproto.string_field(9)
    request_id: str = betterproto.string_field(10)
    # Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    workflow_id_reuse_policy: v1.WorkflowIdReusePolicy = betterproto.enum_field(11)
    # Retries up to workflow_execution_timeout_seconds.
    retry_policy: v1.RetryPolicy = betterproto.message_field(12)
    cron_schedule: str = betterproto.string_field(13)
    memo: v1.Memo = betterproto.message_field(14)
    search_attributes: v1.SearchAttributes = betterproto.message_field(15)
    header: v1.Header = betterproto.message_field(16)


@dataclass
class StartWorkflowExecutionResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)


@dataclass
class GetWorkflowExecutionHistoryRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    execution: v1.WorkflowExecution = betterproto.message_field(2)
    maximum_page_size: int = betterproto.int32_field(3)
    next_page_token: bytes = betterproto.bytes_field(4)
    wait_new_event: bool = betterproto.bool_field(5)
    # Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
    history_event_filter_type: v1.HistoryEventFilterType = betterproto.enum_field(6)
    skip_archival: bool = betterproto.bool_field(7)


@dataclass
class GetWorkflowExecutionHistoryResponse(betterproto.Message):
    history: v1.History = betterproto.message_field(1)
    raw_history: List[v1.DataBlob] = betterproto.message_field(2)
    next_page_token: bytes = betterproto.bytes_field(3)
    archived: bool = betterproto.bool_field(4)


@dataclass
class PollWorkflowTaskQueueRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    task_queue: v1.TaskQueue = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)
    binary_checksum: str = betterproto.string_field(4)


@dataclass
class PollWorkflowTaskQueueResponse(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    workflow_execution: v1.WorkflowExecution = betterproto.message_field(2)
    workflow_type: v1.WorkflowType = betterproto.message_field(3)
    previous_started_event_id: int = betterproto.int64_field(4)
    started_event_id: int = betterproto.int64_field(5)
    attempt: int = betterproto.int64_field(6)
    backlog_count_hint: int = betterproto.int64_field(7)
    history: v1.History = betterproto.message_field(8)
    next_page_token: bytes = betterproto.bytes_field(9)
    query: v1.WorkflowQuery = betterproto.message_field(10)
    workflow_execution_task_queue: v1.TaskQueue = betterproto.message_field(11)
    scheduled_timestamp: int = betterproto.int64_field(12)
    started_timestamp: int = betterproto.int64_field(13)
    queries: Dict[str, v1.WorkflowQuery] = betterproto.map_field(
        14, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class RespondWorkflowTaskCompletedRequest(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    commands: List[v1.Command] = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)
    sticky_attributes: v1.StickyExecutionAttributes = betterproto.message_field(4)
    return_new_workflow_task: bool = betterproto.bool_field(5)
    force_create_new_workflow_task: bool = betterproto.bool_field(6)
    binary_checksum: str = betterproto.string_field(7)
    query_results: Dict[str, v1.WorkflowQueryResult] = betterproto.map_field(
        8, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass
class RespondWorkflowTaskCompletedResponse(betterproto.Message):
    workflow_task: "PollWorkflowTaskQueueResponse" = betterproto.message_field(1)


@dataclass
class RespondWorkflowTaskFailedRequest(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    cause: v1.WorkflowTaskFailedCause = betterproto.enum_field(2)
    failure: v1.Failure = betterproto.message_field(3)
    identity: str = betterproto.string_field(4)
    binary_checksum: str = betterproto.string_field(5)


@dataclass
class RespondWorkflowTaskFailedResponse(betterproto.Message):
    pass


@dataclass
class PollActivityTaskQueueRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    task_queue: v1.TaskQueue = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)
    task_queue_metadata: v1.TaskQueueMetadata = betterproto.message_field(4)


@dataclass
class PollActivityTaskQueueResponse(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    workflow_namespace: str = betterproto.string_field(2)
    workflow_type: v1.WorkflowType = betterproto.message_field(3)
    workflow_execution: v1.WorkflowExecution = betterproto.message_field(4)
    activity_type: v1.ActivityType = betterproto.message_field(5)
    activity_id: str = betterproto.string_field(6)
    header: v1.Header = betterproto.message_field(7)
    input: v1.Payloads = betterproto.message_field(8)
    heartbeat_details: v1.Payloads = betterproto.message_field(9)
    scheduled_timestamp: int = betterproto.int64_field(10)
    scheduled_timestamp_this_attempt: int = betterproto.int64_field(11)
    started_timestamp: int = betterproto.int64_field(12)
    attempt: int = betterproto.int32_field(13)
    # (-- api-linter: core::0140::prepositions=disabled     aip.dev/not-
    # precedent: "to" is used to indicate interval. --)
    schedule_to_close_timeout_seconds: int = betterproto.int32_field(14)
    # (-- api-linter: core::0140::prepositions=disabled     aip.dev/not-
    # precedent: "to" is used to indicate interval. --)
    start_to_close_timeout_seconds: int = betterproto.int32_field(15)
    heartbeat_timeout_seconds: int = betterproto.int32_field(16)
    # This is an actual retry policy the service uses. It can be different from
    # the one provided (or not) during activity scheduling as the service can
    # override the provided one in case its values are not specified or exceed
    # configured system limits.
    retry_policy: v1.RetryPolicy = betterproto.message_field(17)


@dataclass
class RecordActivityTaskHeartbeatRequest(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    details: v1.Payloads = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)


@dataclass
class RecordActivityTaskHeartbeatResponse(betterproto.Message):
    cancel_requested: bool = betterproto.bool_field(1)


@dataclass
class RecordActivityTaskHeartbeatByIdRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_id: str = betterproto.string_field(2)
    run_id: str = betterproto.string_field(3)
    activity_id: str = betterproto.string_field(4)
    details: v1.Payloads = betterproto.message_field(5)
    identity: str = betterproto.string_field(6)


@dataclass
class RecordActivityTaskHeartbeatByIdResponse(betterproto.Message):
    cancel_requested: bool = betterproto.bool_field(1)


@dataclass
class RespondActivityTaskCompletedRequest(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    result: v1.Payloads = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)


@dataclass
class RespondActivityTaskCompletedResponse(betterproto.Message):
    pass


@dataclass
class RespondActivityTaskCompletedByIdRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_id: str = betterproto.string_field(2)
    run_id: str = betterproto.string_field(3)
    activity_id: str = betterproto.string_field(4)
    result: v1.Payloads = betterproto.message_field(5)
    identity: str = betterproto.string_field(6)


@dataclass
class RespondActivityTaskCompletedByIdResponse(betterproto.Message):
    pass


@dataclass
class RespondActivityTaskFailedRequest(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    failure: v1.Failure = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)


@dataclass
class RespondActivityTaskFailedResponse(betterproto.Message):
    pass


@dataclass
class RespondActivityTaskFailedByIdRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_id: str = betterproto.string_field(2)
    run_id: str = betterproto.string_field(3)
    activity_id: str = betterproto.string_field(4)
    failure: v1.Failure = betterproto.message_field(5)
    identity: str = betterproto.string_field(6)


@dataclass
class RespondActivityTaskFailedByIdResponse(betterproto.Message):
    pass


@dataclass
class RespondActivityTaskCanceledRequest(betterproto.Message):
    task_token: bytes = betterproto.bytes_field(1)
    details: v1.Payloads = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)


@dataclass
class RespondActivityTaskCanceledResponse(betterproto.Message):
    pass


@dataclass
class RespondActivityTaskCanceledByIdRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_id: str = betterproto.string_field(2)
    run_id: str = betterproto.string_field(3)
    activity_id: str = betterproto.string_field(4)
    details: v1.Payloads = betterproto.message_field(5)
    identity: str = betterproto.string_field(6)


@dataclass
class RespondActivityTaskCanceledByIdResponse(betterproto.Message):
    pass


@dataclass
class RequestCancelWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_execution: v1.WorkflowExecution = betterproto.message_field(2)
    identity: str = betterproto.string_field(3)
    request_id: str = betterproto.string_field(4)


@dataclass
class RequestCancelWorkflowExecutionResponse(betterproto.Message):
    pass


@dataclass
class SignalWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_execution: v1.WorkflowExecution = betterproto.message_field(2)
    signal_name: str = betterproto.string_field(3)
    input: v1.Payloads = betterproto.message_field(4)
    identity: str = betterproto.string_field(5)
    request_id: str = betterproto.string_field(6)
    control: str = betterproto.string_field(7)


@dataclass
class SignalWorkflowExecutionResponse(betterproto.Message):
    pass


@dataclass
class SignalWithStartWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_id: str = betterproto.string_field(2)
    workflow_type: v1.WorkflowType = betterproto.message_field(3)
    task_queue: v1.TaskQueue = betterproto.message_field(4)
    input: v1.Payloads = betterproto.message_field(5)
    # Total workflow execution timeout including retries and continue as new
    workflow_execution_timeout_seconds: int = betterproto.int32_field(6)
    # Timeout of a single workflow run
    workflow_run_timeout_seconds: int = betterproto.int32_field(7)
    # Timeout of a single workflow task
    workflow_task_timeout_seconds: int = betterproto.int32_field(8)
    identity: str = betterproto.string_field(9)
    request_id: str = betterproto.string_field(10)
    workflow_id_reuse_policy: v1.WorkflowIdReusePolicy = betterproto.enum_field(11)
    signal_name: str = betterproto.string_field(12)
    signal_input: v1.Payloads = betterproto.message_field(13)
    control: str = betterproto.string_field(14)
    # Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    retry_policy: v1.RetryPolicy = betterproto.message_field(15)
    cron_schedule: str = betterproto.string_field(16)
    memo: v1.Memo = betterproto.message_field(17)
    search_attributes: v1.SearchAttributes = betterproto.message_field(18)
    header: v1.Header = betterproto.message_field(19)


@dataclass
class SignalWithStartWorkflowExecutionResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)


@dataclass
class ResetWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_execution: v1.WorkflowExecution = betterproto.message_field(2)
    reason: str = betterproto.string_field(3)
    workflow_task_finish_event_id: int = betterproto.int64_field(4)
    request_id: str = betterproto.string_field(5)


@dataclass
class ResetWorkflowExecutionResponse(betterproto.Message):
    run_id: str = betterproto.string_field(1)


@dataclass
class TerminateWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    workflow_execution: v1.WorkflowExecution = betterproto.message_field(2)
    reason: str = betterproto.string_field(3)
    details: v1.Payloads = betterproto.message_field(4)
    identity: str = betterproto.string_field(5)


@dataclass
class TerminateWorkflowExecutionResponse(betterproto.Message):
    pass


@dataclass
class ListOpenWorkflowExecutionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    maximum_page_size: int = betterproto.int32_field(2)
    next_page_token: bytes = betterproto.bytes_field(3)
    start_time_filter: v1.StartTimeFilter = betterproto.message_field(4)
    execution_filter: v1.WorkflowExecutionFilter = betterproto.message_field(
        5, group="filters"
    )
    type_filter: v1.WorkflowTypeFilter = betterproto.message_field(6, group="filters")


@dataclass
class ListOpenWorkflowExecutionsResponse(betterproto.Message):
    executions: List[v1.WorkflowExecutionInfo] = betterproto.message_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class ListClosedWorkflowExecutionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    maximum_page_size: int = betterproto.int32_field(2)
    next_page_token: bytes = betterproto.bytes_field(3)
    start_time_filter: v1.StartTimeFilter = betterproto.message_field(4)
    execution_filter: v1.WorkflowExecutionFilter = betterproto.message_field(
        5, group="filters"
    )
    type_filter: v1.WorkflowTypeFilter = betterproto.message_field(6, group="filters")
    status_filter: v1.StatusFilter = betterproto.message_field(7, group="filters")


@dataclass
class ListClosedWorkflowExecutionsResponse(betterproto.Message):
    executions: List[v1.WorkflowExecutionInfo] = betterproto.message_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class ListWorkflowExecutionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    page_size: int = betterproto.int32_field(2)
    next_page_token: bytes = betterproto.bytes_field(3)
    query: str = betterproto.string_field(4)


@dataclass
class ListWorkflowExecutionsResponse(betterproto.Message):
    executions: List[v1.WorkflowExecutionInfo] = betterproto.message_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class ListArchivedWorkflowExecutionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    page_size: int = betterproto.int32_field(2)
    next_page_token: bytes = betterproto.bytes_field(3)
    query: str = betterproto.string_field(4)


@dataclass
class ListArchivedWorkflowExecutionsResponse(betterproto.Message):
    executions: List[v1.WorkflowExecutionInfo] = betterproto.message_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class ScanWorkflowExecutionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    page_size: int = betterproto.int32_field(2)
    next_page_token: bytes = betterproto.bytes_field(3)
    query: str = betterproto.string_field(4)


@dataclass
class ScanWorkflowExecutionsResponse(betterproto.Message):
    executions: List[v1.WorkflowExecutionInfo] = betterproto.message_field(1)
    next_page_token: bytes = betterproto.bytes_field(2)


@dataclass
class CountWorkflowExecutionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    query: str = betterproto.string_field(2)


@dataclass
class CountWorkflowExecutionsResponse(betterproto.Message):
    count: int = betterproto.int64_field(1)


@dataclass
class GetSearchAttributesRequest(betterproto.Message):
    pass


@dataclass
class GetSearchAttributesResponse(betterproto.Message):
    keys: Dict[str, v1.IndexedValueType] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_ENUM
    )


@dataclass
class RespondQueryTaskCompletedRequest(betterproto.Message):
    """TODO:  deprecated APIs"""

    task_token: bytes = betterproto.bytes_field(1)
    completed_type: v1.QueryResultType = betterproto.enum_field(2)
    query_result: v1.Payloads = betterproto.message_field(3)
    error_message: str = betterproto.string_field(4)
    worker_version_info: v1.WorkerVersionInfo = betterproto.message_field(5)


@dataclass
class RespondQueryTaskCompletedResponse(betterproto.Message):
    pass


@dataclass
class ResetStickyTaskQueueRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    execution: v1.WorkflowExecution = betterproto.message_field(2)


@dataclass
class ResetStickyTaskQueueResponse(betterproto.Message):
    pass


@dataclass
class QueryWorkflowRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    execution: v1.WorkflowExecution = betterproto.message_field(2)
    query: v1.WorkflowQuery = betterproto.message_field(3)
    # QueryRejectCondition can used to reject the query if workflow state does
    # not satisfy condition. Default: QUERY_REJECT_CONDITION_NONE.
    query_reject_condition: v1.QueryRejectCondition = betterproto.enum_field(4)


@dataclass
class QueryWorkflowResponse(betterproto.Message):
    query_result: v1.Payloads = betterproto.message_field(1)
    query_rejected: v1.QueryRejected = betterproto.message_field(2)


@dataclass
class DescribeWorkflowExecutionRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    execution: v1.WorkflowExecution = betterproto.message_field(2)


@dataclass
class DescribeWorkflowExecutionResponse(betterproto.Message):
    execution_config: v1.WorkflowExecutionConfig = betterproto.message_field(1)
    workflow_execution_info: v1.WorkflowExecutionInfo = betterproto.message_field(2)
    pending_activities: List[v1.PendingActivityInfo] = betterproto.message_field(3)
    pending_children: List[v1.PendingChildExecutionInfo] = betterproto.message_field(4)


@dataclass
class DescribeTaskQueueRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    task_queue: v1.TaskQueue = betterproto.message_field(2)
    task_queue_type: v1.TaskQueueType = betterproto.enum_field(3)
    include_task_queue_status: bool = betterproto.bool_field(4)


@dataclass
class DescribeTaskQueueResponse(betterproto.Message):
    pollers: List[v1.PollerInfo] = betterproto.message_field(1)
    task_queue_status: v1.TaskQueueStatus = betterproto.message_field(2)


@dataclass
class GetClusterInfoRequest(betterproto.Message):
    pass


@dataclass
class GetClusterInfoResponse(betterproto.Message):
    """GetClusterInfoResponse contains information about Temporal cluster"""

    supported_sdk_versions: v1.SupportedSDKVersions = betterproto.message_field(1)


@dataclass
class ListTaskQueuePartitionsRequest(betterproto.Message):
    namespace: str = betterproto.string_field(1)
    task_queue: v1.TaskQueue = betterproto.message_field(2)


@dataclass
class ListTaskQueuePartitionsResponse(betterproto.Message):
    activity_task_queue_partitions: List[
        v1.TaskQueuePartitionMetadata
    ] = betterproto.message_field(1)
    workflow_task_queue_partitions: List[
        v1.TaskQueuePartitionMetadata
    ] = betterproto.message_field(2)


class WorkflowServiceStub(betterproto.ServiceStub):
    """
    WorkflowService API is exposed to provide support for long running
    applications.  Application is expected to call StartWorkflowExecution to
    create an instance for each instance of long running workflow.  Such
    applications are expected to have a worker which regularly polls for
    WorkflowTask and ActivityTask from the WorkflowService.  For each
    WorkflowTask, application is expected to process the history of events for
    that session and respond back with next commands.  For each ActivityTask,
    application is expected to execute the actual logic for that task and
    respond back with completion or failure.  Worker is expected to regularly
    heartbeat while activity task is running.
    """

    async def register_namespace(
        self,
        *,
        name: str = "",
        description: str = "",
        owner_email: str = "",
        workflow_execution_retention_period_days: int = 0,
        emit_metric: bool = False,
        clusters: List[v1.ClusterReplicationConfig] = [],
        active_cluster_name: str = "",
        data: Optional[Dict[str, str]] = None,
        security_token: str = "",
        is_global_namespace: bool = False,
        history_archival_state: v1.ArchivalState = 0,
        history_archival_uri: str = "",
        visibility_archival_state: v1.ArchivalState = 0,
        visibility_archival_uri: str = "",
    ) -> RegisterNamespaceResponse:
        """
        RegisterNamespace creates a new namespace which can be used as a
        container for all resources.  Namespace is a top level entity within
        Temporal, used as a container for all resources like workflow
        executions, task queues, etc.  Namespace acts as a sandbox and provides
        isolation for all resources within the namespace.  All resources
        belongs to exactly one namespace.
        """

        request = RegisterNamespaceRequest()
        request.name = name
        request.description = description
        request.owner_email = owner_email
        request.workflow_execution_retention_period_days = (
            workflow_execution_retention_period_days
        )
        request.emit_metric = emit_metric
        if clusters is not None:
            request.clusters = clusters
        request.active_cluster_name = active_cluster_name
        request.data = data
        request.security_token = security_token
        request.is_global_namespace = is_global_namespace
        request.history_archival_state = history_archival_state
        request.history_archival_uri = history_archival_uri
        request.visibility_archival_state = visibility_archival_state
        request.visibility_archival_uri = visibility_archival_uri

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RegisterNamespace",
            request,
            RegisterNamespaceResponse,
        )

    async def describe_namespace(
        self, *, name: str = "", id: str = ""
    ) -> DescribeNamespaceResponse:
        """
        DescribeNamespace returns the information and configuration for a
        registered namespace.
        """

        request = DescribeNamespaceRequest()
        request.name = name
        request.id = id

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/DescribeNamespace",
            request,
            DescribeNamespaceResponse,
        )

    async def list_namespaces(
        self, *, page_size: int = 0, next_page_token: bytes = b""
    ) -> ListNamespacesResponse:
        """
        ListNamespaces returns the information and configuration for all
        namespaces.
        """

        request = ListNamespacesRequest()
        request.page_size = page_size
        request.next_page_token = next_page_token

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ListNamespaces",
            request,
            ListNamespacesResponse,
        )

    async def update_namespace(
        self,
        *,
        name: str = "",
        update_info: Optional[v1.UpdateNamespaceInfo] = None,
        config: Optional[v1.NamespaceConfig] = None,
        replication_config: Optional[v1.NamespaceReplicationConfig] = None,
        security_token: str = "",
        delete_bad_binary: str = "",
    ) -> UpdateNamespaceResponse:
        """
        (-- api-linter: core::0134::method-signature=disabled     aip.dev/not-
        precedent: UpdateNamespace RPC doesn't follow Google API format. --)
        (-- api-linter: core::0134::response-message-name=disabled
        aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API
        format. --) UpdateNamespace is used to update the information and
        configuration for a registered namespace.
        """

        request = UpdateNamespaceRequest()
        request.name = name
        if update_info is not None:
            request.update_info = update_info
        if config is not None:
            request.config = config
        if replication_config is not None:
            request.replication_config = replication_config
        request.security_token = security_token
        request.delete_bad_binary = delete_bad_binary

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/UpdateNamespace",
            request,
            UpdateNamespaceResponse,
        )

    async def deprecate_namespace(
        self, *, name: str = "", security_token: str = ""
    ) -> DeprecateNamespaceResponse:
        """
        DeprecateNamespace is used to update state of a registered namespace to
        DEPRECATED.  Once the namespace is deprecated it cannot be used to
        start new workflow executions.  Existing workflow executions will
        continue to run on deprecated namespaces.
        """

        request = DeprecateNamespaceRequest()
        request.name = name
        request.security_token = security_token

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/DeprecateNamespace",
            request,
            DeprecateNamespaceResponse,
        )

    async def start_workflow_execution(
        self,
        *,
        namespace: str = "",
        workflow_id: str = "",
        workflow_type: Optional[v1.WorkflowType] = None,
        task_queue: Optional[v1.TaskQueue] = None,
        input: Optional[v1.Payloads] = None,
        workflow_execution_timeout_seconds: int = 0,
        workflow_run_timeout_seconds: int = 0,
        workflow_task_timeout_seconds: int = 0,
        identity: str = "",
        request_id: str = "",
        workflow_id_reuse_policy: v1.WorkflowIdReusePolicy = 0,
        retry_policy: Optional[v1.RetryPolicy] = None,
        cron_schedule: str = "",
        memo: Optional[v1.Memo] = None,
        search_attributes: Optional[v1.SearchAttributes] = None,
        header: Optional[v1.Header] = None,
    ) -> StartWorkflowExecutionResponse:
        """
        StartWorkflowExecution starts a new long running workflow instance.  It
        will create the instance with 'WorkflowExecutionStarted' event in
        history and also schedule the first WorkflowTask for the worker to make
        the first command for this instance.  It will return
        'WorkflowExecutionAlreadyStartedFailure', if an instance already exists
        with same workflowId.
        """

        request = StartWorkflowExecutionRequest()
        request.namespace = namespace
        request.workflow_id = workflow_id
        if workflow_type is not None:
            request.workflow_type = workflow_type
        if task_queue is not None:
            request.task_queue = task_queue
        if input is not None:
            request.input = input
        request.workflow_execution_timeout_seconds = workflow_execution_timeout_seconds
        request.workflow_run_timeout_seconds = workflow_run_timeout_seconds
        request.workflow_task_timeout_seconds = workflow_task_timeout_seconds
        request.identity = identity
        request.request_id = request_id
        request.workflow_id_reuse_policy = workflow_id_reuse_policy
        if retry_policy is not None:
            request.retry_policy = retry_policy
        request.cron_schedule = cron_schedule
        if memo is not None:
            request.memo = memo
        if search_attributes is not None:
            request.search_attributes = search_attributes
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/StartWorkflowExecution",
            request,
            StartWorkflowExecutionResponse,
        )

    async def get_workflow_execution_history(
        self,
        *,
        namespace: str = "",
        execution: Optional[v1.WorkflowExecution] = None,
        maximum_page_size: int = 0,
        next_page_token: bytes = b"",
        wait_new_event: bool = False,
        history_event_filter_type: v1.HistoryEventFilterType = 0,
        skip_archival: bool = False,
    ) -> GetWorkflowExecutionHistoryResponse:
        """
        GetWorkflowExecutionHistory returns the history of specified workflow
        execution.  It fails with 'NotFoundFailure' if specified workflow
        execution in unknown to the service.
        """

        request = GetWorkflowExecutionHistoryRequest()
        request.namespace = namespace
        if execution is not None:
            request.execution = execution
        request.maximum_page_size = maximum_page_size
        request.next_page_token = next_page_token
        request.wait_new_event = wait_new_event
        request.history_event_filter_type = history_event_filter_type
        request.skip_archival = skip_archival

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/GetWorkflowExecutionHistory",
            request,
            GetWorkflowExecutionHistoryResponse,
        )

    async def poll_workflow_task_queue(
        self,
        *,
        namespace: str = "",
        task_queue: Optional[v1.TaskQueue] = None,
        identity: str = "",
        binary_checksum: str = "",
    ) -> PollWorkflowTaskQueueResponse:
        """
        PollWorkflowTaskQueue is called by application worker to process
        WorkflowTask from a specific task queue.  A WorkflowTask is dispatched
        to callers for active workflow executions, with pending commands.
        Application is then expected to call 'RespondWorkflowTaskCompleted' API
        when it is done processing the WorkflowTask. It will also create a
        'WorkflowTaskStarted' event in the history for that session before
        handing off WorkflowTask to application worker.
        """

        request = PollWorkflowTaskQueueRequest()
        request.namespace = namespace
        if task_queue is not None:
            request.task_queue = task_queue
        request.identity = identity
        request.binary_checksum = binary_checksum

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/PollWorkflowTaskQueue",
            request,
            PollWorkflowTaskQueueResponse,
        )

    async def respond_workflow_task_completed(
        self,
        *,
        task_token: bytes = b"",
        commands: List[v1.Command] = [],
        identity: str = "",
        sticky_attributes: Optional[v1.StickyExecutionAttributes] = None,
        return_new_workflow_task: bool = False,
        force_create_new_workflow_task: bool = False,
        binary_checksum: str = "",
        query_results: Optional[Dict[str, v1.WorkflowQueryResult]] = None,
    ) -> RespondWorkflowTaskCompletedResponse:
        """
        RespondWorkflowTaskCompleted is called by application worker to
        complete a WorkflowTask handed as a result of 'PollWorkflowTaskQueue'
        API call.  Completing a WorkflowTask will result in new events for the
        workflow execution and potentially new ActivityTask being created for
        corresponding commands.  It will also create a WorkflowTaskCompleted
        event in the history for that session.  Use the 'taskToken' provided as
        response of PollWorkflowTaskQueue API call for completing the
        WorkflowTask. The response could contain a new workflow task if there
        is one or if the request asking for one.
        """

        request = RespondWorkflowTaskCompletedRequest()
        request.task_token = task_token
        if commands is not None:
            request.commands = commands
        request.identity = identity
        if sticky_attributes is not None:
            request.sticky_attributes = sticky_attributes
        request.return_new_workflow_task = return_new_workflow_task
        request.force_create_new_workflow_task = force_create_new_workflow_task
        request.binary_checksum = binary_checksum
        request.query_results = query_results

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskCompleted",
            request,
            RespondWorkflowTaskCompletedResponse,
        )

    async def respond_workflow_task_failed(
        self,
        *,
        task_token: bytes = b"",
        cause: v1.WorkflowTaskFailedCause = 0,
        failure: Optional[v1.Failure] = None,
        identity: str = "",
        binary_checksum: str = "",
    ) -> RespondWorkflowTaskFailedResponse:
        """
        RespondWorkflowTaskFailed is called by application worker to indicate
        failure.  This results in WorkflowTaskFailedEvent written to the
        history and a new WorkflowTask created.  This API can be used by client
        to either clear sticky task queue or report any panics during
        WorkflowTask processing.  Temporal will only append first
        WorkflowTaskFailed event to the history of workflow execution for
        consecutive failures.
        """

        request = RespondWorkflowTaskFailedRequest()
        request.task_token = task_token
        request.cause = cause
        if failure is not None:
            request.failure = failure
        request.identity = identity
        request.binary_checksum = binary_checksum

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondWorkflowTaskFailed",
            request,
            RespondWorkflowTaskFailedResponse,
        )

    async def poll_activity_task_queue(
        self,
        *,
        namespace: str = "",
        task_queue: Optional[v1.TaskQueue] = None,
        identity: str = "",
        task_queue_metadata: Optional[v1.TaskQueueMetadata] = None,
    ) -> PollActivityTaskQueueResponse:
        """
        PollActivityTaskQueue is called by application worker to process
        ActivityTask from a specific task queue.  ActivityTask is dispatched to
        callers whenever a ScheduleTask command is made for a workflow
        execution. Application is expected to call
        'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it
        is done processing the task. Application also needs to call
        'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds'
        interval to prevent the task from getting timed out.  An event
        'ActivityTaskStarted' event is also written to workflow execution
        history before the ActivityTask is dispatched to application worker.
        """

        request = PollActivityTaskQueueRequest()
        request.namespace = namespace
        if task_queue is not None:
            request.task_queue = task_queue
        request.identity = identity
        if task_queue_metadata is not None:
            request.task_queue_metadata = task_queue_metadata

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/PollActivityTaskQueue",
            request,
            PollActivityTaskQueueResponse,
        )

    async def record_activity_task_heartbeat(
        self,
        *,
        task_token: bytes = b"",
        details: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> RecordActivityTaskHeartbeatResponse:
        """
        RecordActivityTaskHeartbeat is called by application worker while it is
        processing an ActivityTask.  If worker fails to heartbeat within
        'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will
        be marked as timedout and 'ActivityTaskTimedOut' event will be written
        to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
        fail with 'NotFoundFailure' in such situations.  Use the 'taskToken'
        provided as response of PollActivityTaskQueue API call for heart
        beating.
        """

        request = RecordActivityTaskHeartbeatRequest()
        request.task_token = task_token
        if details is not None:
            request.details = details
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeat",
            request,
            RecordActivityTaskHeartbeatResponse,
        )

    async def record_activity_task_heartbeat_by_id(
        self,
        *,
        namespace: str = "",
        workflow_id: str = "",
        run_id: str = "",
        activity_id: str = "",
        details: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> RecordActivityTaskHeartbeatByIdResponse:
        """
        RecordActivityTaskHeartbeatById is called by application worker while
        it is processing an ActivityTask.  If worker fails to heartbeat within
        'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will
        be marked as timed out and 'ActivityTaskTimedOut' event will be written
        to the workflow history.  Calling 'RecordActivityTaskHeartbeatById'
        will fail with 'NotFoundFailure' in such situations.  Instead of using
        'taskToken' like in RecordActivityTaskHeartbeat, use Namespace,
        WorkflowId and ActivityId
        """

        request = RecordActivityTaskHeartbeatByIdRequest()
        request.namespace = namespace
        request.workflow_id = workflow_id
        request.run_id = run_id
        request.activity_id = activity_id
        if details is not None:
            request.details = details
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RecordActivityTaskHeartbeatById",
            request,
            RecordActivityTaskHeartbeatByIdResponse,
        )

    async def respond_activity_task_completed(
        self,
        *,
        task_token: bytes = b"",
        result: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> RespondActivityTaskCompletedResponse:
        """
        RespondActivityTaskCompleted is called by application worker when it is
        done processing an ActivityTask.  It will result in a new
        'ActivityTaskCompleted' event being written to the workflow history and
        a new WorkflowTask created for the workflow so new commands could be
        made.  Use the 'taskToken' provided as response of
        PollActivityTaskQueue API call for completion. It fails with
        'NotFoundFailure' if the taskToken is not valid anymore due to activity
        timeout.
        """

        request = RespondActivityTaskCompletedRequest()
        request.task_token = task_token
        if result is not None:
            request.result = result
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompleted",
            request,
            RespondActivityTaskCompletedResponse,
        )

    async def respond_activity_task_completed_by_id(
        self,
        *,
        namespace: str = "",
        workflow_id: str = "",
        run_id: str = "",
        activity_id: str = "",
        result: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> RespondActivityTaskCompletedByIdResponse:
        """
        RespondActivityTaskCompletedById is called by application worker when
        it is done processing an ActivityTask. It will result in a new
        'ActivityTaskCompleted' event being written to the workflow history and
        a new WorkflowTask created for the workflow so new commands could be
        made.  Similar to RespondActivityTaskCompleted but use Namespace,
        WorkflowId and ActivityId instead of 'taskToken' for completion. It
        fails with 'NotFoundFailure' if the these Ids are not valid anymore due
        to activity timeout.
        """

        request = RespondActivityTaskCompletedByIdRequest()
        request.namespace = namespace
        request.workflow_id = workflow_id
        request.run_id = run_id
        request.activity_id = activity_id
        if result is not None:
            request.result = result
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCompletedById",
            request,
            RespondActivityTaskCompletedByIdResponse,
        )

    async def respond_activity_task_failed(
        self,
        *,
        task_token: bytes = b"",
        failure: Optional[v1.Failure] = None,
        identity: str = "",
    ) -> RespondActivityTaskFailedResponse:
        """
        RespondActivityTaskFailed is called by application worker when it is
        done processing an ActivityTask.  It will result in a new
        'ActivityTaskFailed' event being written to the workflow history and a
        new WorkflowTask created for the workflow instance so new commands
        could be made.  Use the 'taskToken' provided as response of
        PollActivityTaskQueue API call for completion. It fails with
        'NotFoundFailure' if the taskToken is not valid anymore due to activity
        timeout.
        """

        request = RespondActivityTaskFailedRequest()
        request.task_token = task_token
        if failure is not None:
            request.failure = failure
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailed",
            request,
            RespondActivityTaskFailedResponse,
        )

    async def respond_activity_task_failed_by_id(
        self,
        *,
        namespace: str = "",
        workflow_id: str = "",
        run_id: str = "",
        activity_id: str = "",
        failure: Optional[v1.Failure] = None,
        identity: str = "",
    ) -> RespondActivityTaskFailedByIdResponse:
        """
        RespondActivityTaskFailedById is called by application worker when it
        is done processing an ActivityTask. It will result in a new
        'ActivityTaskFailed' event being written to the workflow history and a
        new WorkflowTask created for the workflow instance so new commands
        could be made.  Similar to RespondActivityTaskFailed but use Namespace,
        WorkflowId and ActivityId instead of 'taskToken' for completion. It
        fails with 'NotFoundFailure' if the these Ids are not valid anymore due
        to activity timeout.
        """

        request = RespondActivityTaskFailedByIdRequest()
        request.namespace = namespace
        request.workflow_id = workflow_id
        request.run_id = run_id
        request.activity_id = activity_id
        if failure is not None:
            request.failure = failure
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskFailedById",
            request,
            RespondActivityTaskFailedByIdResponse,
        )

    async def respond_activity_task_canceled(
        self,
        *,
        task_token: bytes = b"",
        details: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> RespondActivityTaskCanceledResponse:
        """
        RespondActivityTaskCanceled is called by application worker when it is
        successfully canceled an ActivityTask.  It will result in a new
        'ActivityTaskCanceled' event being written to the workflow history and
        a new WorkflowTask created for the workflow instance so new commands
        could be made.  Use the 'taskToken' provided as response of
        PollActivityTaskQueue API call for completion. It fails with
        'NotFoundFailure' if the taskToken is not valid anymore due to activity
        timeout.
        """

        request = RespondActivityTaskCanceledRequest()
        request.task_token = task_token
        if details is not None:
            request.details = details
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceled",
            request,
            RespondActivityTaskCanceledResponse,
        )

    async def respond_activity_task_canceled_by_id(
        self,
        *,
        namespace: str = "",
        workflow_id: str = "",
        run_id: str = "",
        activity_id: str = "",
        details: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> RespondActivityTaskCanceledByIdResponse:
        """
        RespondActivityTaskCanceledById is called by application worker when it
        is successfully canceled an ActivityTask. It will result in a new
        'ActivityTaskCanceled' event being written to the workflow history and
        a new WorkflowTask created for the workflow instance so new commands
        could be made.  Similar to RespondActivityTaskCanceled but use
        Namespace, WorkflowId and ActivityId instead of 'taskToken' for
        completion. It fails with 'NotFoundFailure' if the these Ids are not
        valid anymore due to activity timeout.
        """

        request = RespondActivityTaskCanceledByIdRequest()
        request.namespace = namespace
        request.workflow_id = workflow_id
        request.run_id = run_id
        request.activity_id = activity_id
        if details is not None:
            request.details = details
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondActivityTaskCanceledById",
            request,
            RespondActivityTaskCanceledByIdResponse,
        )

    async def request_cancel_workflow_execution(
        self,
        *,
        namespace: str = "",
        workflow_execution: Optional[v1.WorkflowExecution] = None,
        identity: str = "",
        request_id: str = "",
    ) -> RequestCancelWorkflowExecutionResponse:
        """
        RequestCancelWorkflowExecution is called by application worker when it
        wants to request cancellation of a workflow instance. It will result in
        a new 'WorkflowExecutionCancelRequested' event being written to the
        workflow history and a new WorkflowTask created for the workflow
        instance so new commands could be made. It fails with 'NotFoundFailure'
        if the workflow is not valid anymore due to completion or doesn't
        exist.
        """

        request = RequestCancelWorkflowExecutionRequest()
        request.namespace = namespace
        if workflow_execution is not None:
            request.workflow_execution = workflow_execution
        request.identity = identity
        request.request_id = request_id

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RequestCancelWorkflowExecution",
            request,
            RequestCancelWorkflowExecutionResponse,
        )

    async def signal_workflow_execution(
        self,
        *,
        namespace: str = "",
        workflow_execution: Optional[v1.WorkflowExecution] = None,
        signal_name: str = "",
        input: Optional[v1.Payloads] = None,
        identity: str = "",
        request_id: str = "",
        control: str = "",
    ) -> SignalWorkflowExecutionResponse:
        """
        SignalWorkflowExecution is used to send a signal event to running
        workflow execution.  This results in WorkflowExecutionSignaled event
        recorded in the history and a workflow task being created for the
        execution.
        """

        request = SignalWorkflowExecutionRequest()
        request.namespace = namespace
        if workflow_execution is not None:
            request.workflow_execution = workflow_execution
        request.signal_name = signal_name
        if input is not None:
            request.input = input
        request.identity = identity
        request.request_id = request_id
        request.control = control

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/SignalWorkflowExecution",
            request,
            SignalWorkflowExecutionResponse,
        )

    async def signal_with_start_workflow_execution(
        self,
        *,
        namespace: str = "",
        workflow_id: str = "",
        workflow_type: Optional[v1.WorkflowType] = None,
        task_queue: Optional[v1.TaskQueue] = None,
        input: Optional[v1.Payloads] = None,
        workflow_execution_timeout_seconds: int = 0,
        workflow_run_timeout_seconds: int = 0,
        workflow_task_timeout_seconds: int = 0,
        identity: str = "",
        request_id: str = "",
        workflow_id_reuse_policy: v1.WorkflowIdReusePolicy = 0,
        signal_name: str = "",
        signal_input: Optional[v1.Payloads] = None,
        control: str = "",
        retry_policy: Optional[v1.RetryPolicy] = None,
        cron_schedule: str = "",
        memo: Optional[v1.Memo] = None,
        search_attributes: Optional[v1.SearchAttributes] = None,
        header: Optional[v1.Header] = None,
    ) -> SignalWithStartWorkflowExecutionResponse:
        """
        SignalWithStartWorkflowExecution is used to ensure sending signal to a
        workflow. If the workflow is running, this results in
        WorkflowExecutionSignaled event being recorded in the history and a
        workflow task being created for the execution. If the workflow is not
        running or not found, this results in WorkflowExecutionStarted and
        WorkflowExecutionSignaled events being recorded in history, and a
        workflow task being created for the execution
        """

        request = SignalWithStartWorkflowExecutionRequest()
        request.namespace = namespace
        request.workflow_id = workflow_id
        if workflow_type is not None:
            request.workflow_type = workflow_type
        if task_queue is not None:
            request.task_queue = task_queue
        if input is not None:
            request.input = input
        request.workflow_execution_timeout_seconds = workflow_execution_timeout_seconds
        request.workflow_run_timeout_seconds = workflow_run_timeout_seconds
        request.workflow_task_timeout_seconds = workflow_task_timeout_seconds
        request.identity = identity
        request.request_id = request_id
        request.workflow_id_reuse_policy = workflow_id_reuse_policy
        request.signal_name = signal_name
        if signal_input is not None:
            request.signal_input = signal_input
        request.control = control
        if retry_policy is not None:
            request.retry_policy = retry_policy
        request.cron_schedule = cron_schedule
        if memo is not None:
            request.memo = memo
        if search_attributes is not None:
            request.search_attributes = search_attributes
        if header is not None:
            request.header = header

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/SignalWithStartWorkflowExecution",
            request,
            SignalWithStartWorkflowExecutionResponse,
        )

    async def reset_workflow_execution(
        self,
        *,
        namespace: str = "",
        workflow_execution: Optional[v1.WorkflowExecution] = None,
        reason: str = "",
        workflow_task_finish_event_id: int = 0,
        request_id: str = "",
    ) -> ResetWorkflowExecutionResponse:
        """
        ResetWorkflowExecution reset an existing workflow execution to
        WorkflowTaskCompleted event(exclusive). And it will immediately
        terminating the current execution instance.
        """

        request = ResetWorkflowExecutionRequest()
        request.namespace = namespace
        if workflow_execution is not None:
            request.workflow_execution = workflow_execution
        request.reason = reason
        request.workflow_task_finish_event_id = workflow_task_finish_event_id
        request.request_id = request_id

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ResetWorkflowExecution",
            request,
            ResetWorkflowExecutionResponse,
        )

    async def terminate_workflow_execution(
        self,
        *,
        namespace: str = "",
        workflow_execution: Optional[v1.WorkflowExecution] = None,
        reason: str = "",
        details: Optional[v1.Payloads] = None,
        identity: str = "",
    ) -> TerminateWorkflowExecutionResponse:
        """
        TerminateWorkflowExecution terminates an existing workflow execution by
        recording WorkflowExecutionTerminated event in the history and
        immediately terminating the execution instance.
        """

        request = TerminateWorkflowExecutionRequest()
        request.namespace = namespace
        if workflow_execution is not None:
            request.workflow_execution = workflow_execution
        request.reason = reason
        if details is not None:
            request.details = details
        request.identity = identity

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/TerminateWorkflowExecution",
            request,
            TerminateWorkflowExecutionResponse,
        )

    async def list_open_workflow_executions(
        self,
        *,
        namespace: str = "",
        maximum_page_size: int = 0,
        next_page_token: bytes = b"",
        start_time_filter: Optional[v1.StartTimeFilter] = None,
        execution_filter: Optional[v1.WorkflowExecutionFilter] = None,
        type_filter: Optional[v1.WorkflowTypeFilter] = None,
    ) -> ListOpenWorkflowExecutionsResponse:
        """
        ListOpenWorkflowExecutions is a visibility API to list the open
        executions in a specific namespace.
        """

        request = ListOpenWorkflowExecutionsRequest()
        request.namespace = namespace
        request.maximum_page_size = maximum_page_size
        request.next_page_token = next_page_token
        if start_time_filter is not None:
            request.start_time_filter = start_time_filter
        if execution_filter is not None:
            request.execution_filter = execution_filter
        if type_filter is not None:
            request.type_filter = type_filter

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ListOpenWorkflowExecutions",
            request,
            ListOpenWorkflowExecutionsResponse,
        )

    async def list_closed_workflow_executions(
        self,
        *,
        namespace: str = "",
        maximum_page_size: int = 0,
        next_page_token: bytes = b"",
        start_time_filter: Optional[v1.StartTimeFilter] = None,
        execution_filter: Optional[v1.WorkflowExecutionFilter] = None,
        type_filter: Optional[v1.WorkflowTypeFilter] = None,
        status_filter: Optional[v1.StatusFilter] = None,
    ) -> ListClosedWorkflowExecutionsResponse:
        """
        ListClosedWorkflowExecutions is a visibility API to list the closed
        executions in a specific namespace.
        """

        request = ListClosedWorkflowExecutionsRequest()
        request.namespace = namespace
        request.maximum_page_size = maximum_page_size
        request.next_page_token = next_page_token
        if start_time_filter is not None:
            request.start_time_filter = start_time_filter
        if execution_filter is not None:
            request.execution_filter = execution_filter
        if type_filter is not None:
            request.type_filter = type_filter
        if status_filter is not None:
            request.status_filter = status_filter

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ListClosedWorkflowExecutions",
            request,
            ListClosedWorkflowExecutionsResponse,
        )

    async def list_workflow_executions(
        self,
        *,
        namespace: str = "",
        page_size: int = 0,
        next_page_token: bytes = b"",
        query: str = "",
    ) -> ListWorkflowExecutionsResponse:
        """
        ListWorkflowExecutions is a visibility API to list workflow executions
        in a specific namespace.
        """

        request = ListWorkflowExecutionsRequest()
        request.namespace = namespace
        request.page_size = page_size
        request.next_page_token = next_page_token
        request.query = query

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ListWorkflowExecutions",
            request,
            ListWorkflowExecutionsResponse,
        )

    async def list_archived_workflow_executions(
        self,
        *,
        namespace: str = "",
        page_size: int = 0,
        next_page_token: bytes = b"",
        query: str = "",
    ) -> ListArchivedWorkflowExecutionsResponse:
        """
        ListArchivedWorkflowExecutions is a visibility API to list archived
        workflow executions in a specific namespace.
        """

        request = ListArchivedWorkflowExecutionsRequest()
        request.namespace = namespace
        request.page_size = page_size
        request.next_page_token = next_page_token
        request.query = query

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ListArchivedWorkflowExecutions",
            request,
            ListArchivedWorkflowExecutionsResponse,
        )

    async def scan_workflow_executions(
        self,
        *,
        namespace: str = "",
        page_size: int = 0,
        next_page_token: bytes = b"",
        query: str = "",
    ) -> ScanWorkflowExecutionsResponse:
        """
        ScanWorkflowExecutions is a visibility API to list large amount of
        workflow executions in a specific namespace without order.
        """

        request = ScanWorkflowExecutionsRequest()
        request.namespace = namespace
        request.page_size = page_size
        request.next_page_token = next_page_token
        request.query = query

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ScanWorkflowExecutions",
            request,
            ScanWorkflowExecutionsResponse,
        )

    async def count_workflow_executions(
        self, *, namespace: str = "", query: str = ""
    ) -> CountWorkflowExecutionsResponse:
        """
        CountWorkflowExecutions is a visibility API to count of workflow
        executions in a specific namespace.
        """

        request = CountWorkflowExecutionsRequest()
        request.namespace = namespace
        request.query = query

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/CountWorkflowExecutions",
            request,
            CountWorkflowExecutionsResponse,
        )

    async def get_search_attributes(self) -> GetSearchAttributesResponse:
        """
        GetSearchAttributes is a visibility API to get all legal keys that
        could be used in list APIs
        """

        request = GetSearchAttributesRequest()

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/GetSearchAttributes",
            request,
            GetSearchAttributesResponse,
        )

    async def respond_query_task_completed(
        self,
        *,
        task_token: bytes = b"",
        completed_type: v1.QueryResultType = 0,
        query_result: Optional[v1.Payloads] = None,
        error_message: str = "",
        worker_version_info: Optional[v1.WorkerVersionInfo] = None,
    ) -> RespondQueryTaskCompletedResponse:
        """
        RespondQueryTaskCompleted is called by application worker to complete a
        QueryTask (which is a WorkflowTask for query) as a result of
        'PollWorkflowTaskQueue' API call. Completing a QueryTask will unblock
        the client call to 'QueryWorkflow' API and return the query result to
        client as a response to 'QueryWorkflow' API call.
        """

        request = RespondQueryTaskCompletedRequest()
        request.task_token = task_token
        request.completed_type = completed_type
        if query_result is not None:
            request.query_result = query_result
        request.error_message = error_message
        if worker_version_info is not None:
            request.worker_version_info = worker_version_info

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/RespondQueryTaskCompleted",
            request,
            RespondQueryTaskCompletedResponse,
        )

    async def reset_sticky_task_queue(
        self, *, namespace: str = "", execution: Optional[v1.WorkflowExecution] = None
    ) -> ResetStickyTaskQueueResponse:
        """
        ResetStickyTaskQueue resets the sticky task queue related information
        in mutable state of a given workflow. Things cleared are: 1.
        StickyTaskQueue 2. StickyScheduleToStartTimeout 3. ClientLibraryVersion
        4. ClientFeatureVersion 5. ClientImpl
        """

        request = ResetStickyTaskQueueRequest()
        request.namespace = namespace
        if execution is not None:
            request.execution = execution

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ResetStickyTaskQueue",
            request,
            ResetStickyTaskQueueResponse,
        )

    async def query_workflow(
        self,
        *,
        namespace: str = "",
        execution: Optional[v1.WorkflowExecution] = None,
        query: Optional[v1.WorkflowQuery] = None,
        query_reject_condition: v1.QueryRejectCondition = 0,
    ) -> QueryWorkflowResponse:
        """
        QueryWorkflow returns query result for a specified workflow execution
        """

        request = QueryWorkflowRequest()
        request.namespace = namespace
        if execution is not None:
            request.execution = execution
        if query is not None:
            request.query = query
        request.query_reject_condition = query_reject_condition

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/QueryWorkflow",
            request,
            QueryWorkflowResponse,
        )

    async def describe_workflow_execution(
        self, *, namespace: str = "", execution: Optional[v1.WorkflowExecution] = None
    ) -> DescribeWorkflowExecutionResponse:
        """
        DescribeWorkflowExecution returns information about the specified
        workflow execution.
        """

        request = DescribeWorkflowExecutionRequest()
        request.namespace = namespace
        if execution is not None:
            request.execution = execution

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/DescribeWorkflowExecution",
            request,
            DescribeWorkflowExecutionResponse,
        )

    async def describe_task_queue(
        self,
        *,
        namespace: str = "",
        task_queue: Optional[v1.TaskQueue] = None,
        task_queue_type: v1.TaskQueueType = 0,
        include_task_queue_status: bool = False,
    ) -> DescribeTaskQueueResponse:
        """
        DescribeTaskQueue returns information about the target task queue,
        right now this API returns the pollers which polled this task queue in
        last few minutes.
        """

        request = DescribeTaskQueueRequest()
        request.namespace = namespace
        if task_queue is not None:
            request.task_queue = task_queue
        request.task_queue_type = task_queue_type
        request.include_task_queue_status = include_task_queue_status

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/DescribeTaskQueue",
            request,
            DescribeTaskQueueResponse,
        )

    async def get_cluster_info(self) -> GetClusterInfoResponse:
        """GetClusterInfo returns information about temporal cluster"""

        request = GetClusterInfoRequest()

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/GetClusterInfo",
            request,
            GetClusterInfoResponse,
        )

    async def list_task_queue_partitions(
        self, *, namespace: str = "", task_queue: Optional[v1.TaskQueue] = None
    ) -> ListTaskQueuePartitionsResponse:
        request = ListTaskQueuePartitionsRequest()
        request.namespace = namespace
        if task_queue is not None:
            request.task_queue = task_queue

        return await self._unary_unary(
            "/temporal.api.workflowservice.v1.WorkflowService/ListTaskQueuePartitions",
            request,
            ListTaskQueuePartitionsResponse,
        )
